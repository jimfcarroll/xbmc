<%
import Helper
import SwigTypeParser
import bindings.PythonTools
import bindings.MethodType

import groovy.xml.XmlUtil
import groovy.text.SimpleTemplateEngine
import java.util.regex.Pattern

/**
 * All of the method nodes and all of the class nodes are used several
 * times over, so they are pulled out once here.
 */

// initialize the SwigTypeParser with the module's typetables
module.findAll( { it.name() == 'typetab' } ).each {  SwigTypeParser.appendTypeTable(it) }

methods = module.depthFirst().findAll { it.name() == 'function' || it.name() == 'constructor' || it.name() == 'destructor' }
classes = module.depthFirst().findAll { it.name() == 'class' }

Helper.setup(classes,
    /**
     * This is meant to contain mini-templates for converting the return type
     * of the native call to be returned to the python caller.
     */
    [ 'void' : 'Py_INCREF(Py_None);\n    ${result} = Py_None;',
      'long': '${result} = PyInt_FromLong(${api});',
      'unsigned long': '${result} = PyInt_FromLong(${api});',
      'bool': '${result} = Py_BuildValue((char*)"b", ${api});',
      'int': '${result} = Py_BuildValue((char*)"i", ${api});',
      'double': '${result} = PyFloat_FromDouble(${api});',
      'float': '${result} = Py_BuildValue((char*)"f", ${api});',
      'CStdString' : new File('generator/bindings/python.string.outtm'),
      'String' : new File('generator/bindings/python.string.outtm'),
      'p.q(const).char' : '${result} = PyString_FromString(${api});',
      (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('generator/bindings/python.vector.outtm')
    ], '${result} = makePythonInstance(${api},&Py${Helper.findFullClassName(classnode).replaceAll(\'::\',\'_\')}_Type,"${type}");',
    /**
     * This is meant to contain mini-templates for converting the parameter types
     * of the native call to be converted from the python types provided by the caller.
     *
     * Note: if the type can be handled by PythonTools.ltypeToFormatChar then it wont
     * appear here as it gets converted directly within the PyArg_ParseTupleAndKeywords
     * call.
     */
    [ 
      'String' : 'if (${pyarg}) PyXBMCGetUnicodeString(${api},${pyarg},false,"${api}","${method.@name}");',
      'CStdString' : 'if (${pyarg}) PyXBMCGetUnicodeString(${api},${pyarg},false,"${api}","${method.@name}");',
      (Pattern.compile('''(p.){0,1}std::vector<\\(.*\\)>''')) : new File('generator/bindings/python.vector.intm'),
      // I shouldn't need both of these but my parser doesn't resolve namespaces within
      //  parameter declarations. TODO: Maybe I should fix this.
      'r.q(const).Dictionary' : new File('generator/bindings/python.dict.intm'),
      'r.q(const).XBMCAddon::Dictionary' : new File('generator/bindings/python.dict.intm'),
      (Pattern.compile('''(p.){0,1}std::map<\\(.*\\)>''')) : new File('generator/bindings/python.map.intm')
    ], '${api} = (${swigTypeParser.SwigType_str(ltype)})retrieveApiInstance(${pyarg},"${ltype}","${helper.callingName(method)}");')

//println 'this: ' + this.binding.getVariables()

void doMethod(method, MethodType methodType)
{
  boolean constructor = methodType == MethodType.constructor

  // if we're a constructor, but we're private, then we're outta here
  if (constructor && method.@access != null && method.@access != "public")
    return

  boolean destructor = methodType == MethodType.destructor
  List params = method?.parm
  int numParams = params?.size()
  String clazz = Helper.findFullClassName(method)
  String returns = constructor ? 'p.' + clazz : (destructor ? 'void' : Helper.getReturnSwigType(method))
  Node classnode = Helper.findClassNode(method)
  String classNameAsVariable = clazz == null ? null : PythonTools.getClassNameAsVariable(classnode)

  // TODO: Documentation
%>
  static <% if(methodType == MethodType.destructor) { %>void<% } else { %>PyObject*<% } %> ${module.@name}_${PythonTools.getPyMethodName(method,methodType)} (<%= ((clazz == null) ? "PyObject" : 
                   (constructor ? "PyTypeObject" : 'PyHolder')) %>* ${constructor ? 'pytype' : 'self'} <% 
                   if (methodType != MethodType.destructor) { %> , PyObject *args, PyObject *kwds <%} %> )
  {
    CLog::Log(LOGDEBUG, "NEWADDON Entering the Python method \\"${PythonTools.getPyMethodName(method,methodType)}\\"");
<%  if (numParams > 0)
    { %>
    static const char *keywords[] = {
<%    params.each { %>
          "${it.@name}",<% } %>
          NULL};

<%    params.each { 
%>         
    ${SwigTypeParser.SwigType_str(SwigTypeParser.convertTypeToLTypeForParam(it.@type))} ${it.@name} ${it.@value != null ? ' = ' + it.@value : ''};<%
        if (!PythonTools.parameterCanBeUsedDirectly(it))
        { %>
    PyObject* py${it.@name} = NULL;<%
        }
     } %>
    if (!PyArg_ParseTupleAndKeywords(
       args,
       kwds,
       (char*)"<%= PythonTools.makeFormatStringFromParameters(method) %>",
       (char**)keywords,<%    params.eachWithIndex { param,i -> %>
         &${PythonTools.parameterCanBeUsedDirectly(param) ? '' : 'py'}${param.@name}${i < params.size() - 1 ? "," : ""}<% } %>
       ))
    {
      CLog::Log(LOGDEBUG, "NEWADDON Leaving Python method \\"${PythonTools.getPyMethodName(method,methodType)}\\" ... returning NULL");
      return NULL;
    }

<%
    // now do the input converstion if any are necessary
    params.findAll({ !PythonTools.parameterCanBeUsedDirectly(it) }).each { %>    ${Helper.getInConversion(it.@type, it.@name, method)} <% println() }
%>
<%  }
    // now actually invoke the method
    if (returns != "void") { %>    ${SwigTypeParser.SwigType_str(returns)} apiResult;<%   }
%>
    try
    {
<%
    // now do the method call itself
    if (!destructor) {
    if (constructor) {  %>      XBMCAddon::LanguageHook::setLanguageHook(XBMCAddon::Python::LanguageHook::getInstance());<% println() }
%>      <%
    if (returns != "void") { %>apiResult = <% }
    if (clazz && !constructor && !destructor) {
%>((${clazz}*)retrieveApiInstance((PyObject*)self,&Py${classNameAsVariable}_Type,"${Helper.callingName(method)}","${clazz}"))-> <%
    }
    if (constructor && classnode.@feature_director) { 
    %>(&Py${classNameAsVariable}_Type != pytype) ? new ${classNameAsVariable}_Director(<% params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %>) : <% }
    %>${Helper.callingName(method)}( <% params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %> );
<%
      if (constructor && classnode.@feature_ref != null) {  %>      ${new SimpleTemplateEngine().createTemplate(classnode.@feature_ref).make(['ths' : 'apiResult']).toString()} <% }
    } // close the 'if method is not a destructor'
    else {  // it is a destructor
%>
      ${clazz}* theObj = (${clazz}*)retrieveApiInstance((PyObject*)self,&Py${classNameAsVariable}_Type,"~${Helper.callingName(method)}","${clazz}");
      if (theObj != NULL)
      { <%
        if (classnode != null && classnode && classnode.@feature_unref != null) 
        {  %>
          ${new SimpleTemplateEngine().createTemplate(classnode.@feature_unref).make(['ths' : 'theObj']).toString()}<%
        }
%>
      }
<%
    }
%>
    }
    catch (XBMCAddon::Exception e)
    { 
      CLog::Log(LOGERROR,"Leaving Python method \\"${PythonTools.getPyMethodName(method,methodType)}\\". Exception from call to \"${Helper.callingName(method)}\" \"%s\" ... returning NULL", e.getMessage().c_str());
      PyErr_SetString(PyExc_RuntimeError, e.getMessage().c_str()); <%
      if (!destructor) {  %>
      return NULL; <%
      } %>
    }
    catch (...)
    {
      CLog::Log(LOGERROR,"Unknown exception thrown from the call \"${Helper.callingName(method)}\"");
      PyErr_SetString(PyExc_RuntimeError, "Unknown exception thrown from the call \"${Helper.callingName(method)}\""); <%
      if (!destructor) {  %>
      return NULL; <%
      } %>
    }
<%
    if (!destructor) { %>
    PyObject* result;

    // transform the result
<%
    if (constructor) {
%>    result = makePythonInstance(apiResult,pytype,"${returns}");<%
    }
    else { 
%>    ${Helper.getOutConversion(returns,method)}<%
    }
    if (constructor && method.@feature_director) { %>
    if (&Py${classNameAsVariable}_Type != pytype) 
      ((${classNameAsVariable}_Director*)apiResult)->setPyObjectForDirector(result);<%
    }
 %>

    return result; <% } 
    else { %>
    self->ob_type->tp_free((PyObject*)self); 
    <%
    }
    %>
  } <%
}

void doClassTypeInfo(Node clazz, List classNameAsVariables = null)
{ 
  String classNameAsVariable = PythonTools.getClassNameAsVariable(clazz)
  String fullClassName = Helper.findFullClassName(clazz)
  classNameAsVariables?.add(classNameAsVariable)
%>
  //=========================================================================
  // This variable will hold the Python Type information for ${fullClassName}
  PyTypeObject Py${classNameAsVariable}_Type;
  //=========================================================================
<%    
}

void doClassMethodInfo(Node clazz, List initTypeCalls = null)
{ 
  String classNameAsVariable = PythonTools.getClassNameAsVariable(clazz)
  String fullClassName = Helper.findFullClassName(clazz)
  String initTypeCall = "initPy${classNameAsVariable}_Type"
  initTypeCalls?.add(initTypeCall)
%>
  //=========================================================================
  // This section contains the initialization for the
  // Python extention for the Api class ${fullClassName}
  //=========================================================================
  // All of the methods on this class
  static PyMethodDef ${classNameAsVariable}_methods[] = { <%
    clazz.function.each {  %>
    {(char*)"${it.@sym_name}", (PyCFunction)${module.@name}_${PythonTools.getPyMethodName(it,MethodType.method)}, METH_VARARGS|METH_KEYWORDS, NULL}, <% }

    // now do all of the explcit feature:python:method's that may be in this class
    List tmpl = []
    tmpl.addAll(clazz.attributes().keySet())
    List newMethodKeys = tmpl.findAll { it.startsWith('feature_python_method_') }
    newMethodKeys.each { key -> 
      String featureEntry = clazz.attribute(key)
      String methodName = key.substring('feature_python_method_'.length()) %>
    {(char*)"${methodName}", (PyCFunction)${module.@name}_${PythonTools.getClassNameAsVariable(clazz)}_${methodName}, METH_VARARGS|METH_KEYWORDS, NULL},
<%
    }

%>
    {NULL, NULL, 0, NULL}
  };

  // This method initializes the above mentioned Python Type structure
  static void ${initTypeCall}()
  {
    PyXBMCInitializeTypeObject(&Py${classNameAsVariable}_Type);

    Py${classNameAsVariable}_Type.tp_name = (char*)"${module.@name}.${clazz.@sym_name}";
    Py${classNameAsVariable}_Type.tp_basicsize = sizeof(PyHolder);
    Py${classNameAsVariable}_Type.tp_dealloc = (destructor)${module.@name}_${classNameAsVariable}_Dealloc;
    Py${classNameAsVariable}_Type.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE;
    Py${classNameAsVariable}_Type.tp_doc = NULL; // TODO: fill in the docs
    Py${classNameAsVariable}_Type.tp_methods = ${classNameAsVariable}_methods; <%
    // I need to find the base type if there is a known class with it
    assert clazz.baselist.size() < 2, "${clazz} has multiple baselists - need to write code to separate out the public one."
    String baseclass = 'NULL'
    List knownbases = []
    if (clazz.baselist)
    { 
      if (clazz.baselist[0].base) clazz.baselist[0].base.each {
          Node baseclassnode = Helper.findClassNodeByName(module,it.@name,clazz)
          if (baseclassnode) knownbases.add(baseclassnode)
          else System.out.println("WARNING: the base class ${it.@name} for ${fullClassName} is unrecognized within ${module.@name}.")
        }
    }
    assert knownbases.size() < 2, 
           "The class ${fullClassName} has too many known base classes. Multiple inheritance isn't supported in the code generator. Please \"#ifdef SWIG\" out all but one."
    if (knownbases.size() > 0)
      baseclass = "&Py${PythonTools.getClassNameAsVariable(knownbases[0])}_Type"
%>
    Py${classNameAsVariable}_Type.tp_base = ${baseclass};
    Py${classNameAsVariable}_Type.tp_new = <% Helper.hasHiddenConstructor(clazz) ? print('NULL') : print("${module.@name}_${classNameAsVariable}_New") %>;
  }
  //=========================================================================
<%
}

List getAllVirtualMethods(Node clazz)
{
  List ret = []
  ret.addAll(clazz.findAll({ it.name() == 'function' && it.@storage && it.@storage == 'virtual' }))
  if (clazz.baselist) { 
    if (clazz.baselist[0].base) clazz.baselist[0].base.each {
        Node baseclassnode = Helper.findClassNodeByName(module,it.@name,clazz)
        if (baseclassnode && baseclassnode.@feature_director) ret.addAll(getAllVirtualMethods(baseclassnode))
      }
  }
  return ret;
}

%>
/*
 *      Copyright (C) 2005-2012 Team XBMC
 *      http://www.xbmc.org
 *
 *  This Program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  This Program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with XBMC; see the file COPYING.  If not, write to
 *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 *  http://www.gnu.org/copyleft/gpl.html
 *
 */

// ************************************************************************
// This file was generated by xbmc compile process. DO NOT EDIT!!
//  It was created by running the code generator on the spec file for
//  the module "${module.@name}" on the template file PythonSwig.template.cpp
// ************************************************************************

<%
Helper.getInsertNodes(module, 'begin').each { %>${Helper.unescape(it)}<% }
%>

#include <Python.h>
#include <string>
#include "swig/python/LanguageHook.h"
#include "swig/python/swig.h"
#include "native/Exception.h"
#include "native/LanguageHook.h"

<%
Helper.getInsertNodes(module, 'header').each { %>${Helper.unescape(it)}<% }
%>

namespace PythonBindings
{
<%
  List initTypeCalls = []
  List classNameAsVariables = []

  classes.each { clazz -> doClassTypeInfo(clazz, classNameAsVariables) }
%>

<%
//=========================================================================
// Do the directors
  classes.findAll({ it.@feature_director != null }).each { clazz ->
    // find the constructor for this class
    constructor = clazz.constructor[0]
%>
  //=========================================================================
  // This class is the Director for ${Helper.findFullClassName(clazz)}. 
  // It provides the "reverse bridge" from C++ to Python to support 
  // cross-language polymorphism.
  //=========================================================================
  class ${PythonTools.getClassNameAsVariable(clazz)}_Director : public Director, public ${clazz.@name}
  {
    public:
<%
      if (constructor)
      {%>
      inline ${PythonTools.getClassNameAsVariable(clazz)}_Director(<%
        List params = constructor?.parm
        params.eachWithIndex { param, i -> %>${SwigTypeParser.SwigType_str(param.@type)} ${param.@name}${i < params.size() - 1 ? "," : ""} <% }
        %>) : ${Helper.findFullClassName(constructor)}(<% 
        params.eachWithIndex { param, i -> %> ${param.@name}${i < params.size() - 1 ? "," : ""} <% } %>) { } <%
      }

      getAllVirtualMethods(clazz).each
      { %>
      virtual ${SwigTypeParser.SwigType_str(Helper.getReturnSwigType(it))} ${Helper.callingName(it)}( <%
    List params = it?.parm
    String paramFormatStr = ''
    params.each { paramFormatStr += 'O' }
    params.eachWithIndex { param, i -> %> ${SwigTypeParser.SwigType_str(param.@type)} ${param.@name}${i < params.size() - 1 ? "," : ""} <% }
    %> )
      { <%
        params.each
        { param ->
          %>
        PyObject* py${param.@name} = NULL;
        ${Helper.getOutConversion(param.@type,it,['result' : 'py' + param.@name, 'api' : param.@name])}<%
        }
%>
        PyObject_CallMethod(self,(char*)"${Helper.callingName(it)}",(char*)"(${paramFormatStr})"<%
          params.each {
             %>, py${it.@name} <%
          }
        %>);
      }
<%    }
      
%>
  };
<%
  }
//=========================================================================

  // types used as method parameter or return values need to be declared
  // as extern if they are unknown types.

  methods.each { if (it.name() != 'destructor') { doMethod(it, (it.name() == 'constructor' ? MethodType.constructor : MethodType.method)); println(); } }
  classes.each { clazz -> doMethod(clazz, MethodType.destructor) }

  // now find any methods that have been added explicitly
  classes.each { node ->
    List tmpl = []
    tmpl.addAll(node.attributes().keySet())
    List newMethodKeys = tmpl.findAll { it.startsWith('feature_python_method_') }
    newMethodKeys.each { key -> 
      String featureEntry = node.attribute(key)
      String methodName = key.substring('feature_python_method_'.length()) %>
  static PyObject* ${module.@name}_${PythonTools.getClassNameAsVariable(node)}_${methodName}(PyObject* self, PyObject *args, PyObject *kwds)
  ${Helper.unescape(featureEntry)}
<%
    }
  }

  classes.each { clazz -> doClassMethodInfo(clazz, initTypeCalls) }
%>

  static PyMethodDef ${module.@name}_methods[] = { <%
    module.depthFirst().findAll({ it.name() == 'function' && Helper.parents(it, { Node lnode -> lnode.name() == 'class'}).size() == 0 }).each {  %>
    {(char*)"${it.@sym_name}", (PyCFunction)${module.@name}_${PythonTools.getPyMethodName(it,MethodType.method)}, METH_VARARGS|METH_KEYWORDS, NULL}, <% }
%>
    {NULL, NULL, 0, NULL}
  };

  // This is the call that will call all of the other initializes 
  //  for all of the classes in this module
  static void initTypes()
  {
    static bool typesAlreadyInitialized = false;
    if (!typesAlreadyInitialized)
    {
      typesAlreadyInitialized = true;
<%
      initTypeCalls.each { %>
      ${it}();<%
      }

      classNameAsVariables.each { %>
      if (PyType_Ready(&Py${it}_Type) < 0)
        return;<%
      }%>
    }
  }

  void initModule_${module.@name}()
  {
    initTypes();

    // init general ${module.@name} modules
    PyObject* module;

<% classNameAsVariables.each { %>
    Py_INCREF(&Py${it}_Type);<%
   }%>

    module = Py_InitModule((char*)"${module.@name}", ${module.@name}_methods);
    if (module == NULL) return;

<% classes.each { clazz -> %>
    PyModule_AddObject(module, (char*)"${clazz.@sym_name}", (PyObject*)&Py${PythonTools.getClassNameAsVariable(clazz)}_Type);<%
   }%>

   // constants
   PyModule_AddStringConstant(module, (char*)"__author__", (char*)"Team XBMC <www.xbmc.org>");
   PyModule_AddStringConstant(module, (char*)"__date__", (char*)"${new Date().toString()}");
   PyModule_AddStringConstant(module, (char*)"__version__", (char*)"2.0");
   PyModule_AddStringConstant(module, (char*)"__credits__", (char*)"Team XBMC");
   PyModule_AddStringConstant(module, (char*)"__platform__", (char*)"ALL");

   // need to handle constants
<% module.depthFirst().findAll( { it.name() == 'constant'} ).each { 
     String pyCall = 
        (it.@type == 'int' || it.@type == 'long' || it.@type == 'unsigned int' || it.@type == 'unsigned long' || it.@type == 'bool') ? 
        'PyModule_AddIntConstant' : 'PyModule_AddStringConstant' %>
   ${pyCall}(module,"${it.@sym_name}",(int)${it.@value}); <%
  } %>
  }

} // end PythonBindings namespace for python type definitions

